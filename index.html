<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>自然な木の3D画像生成プログラム - 形質の多様性</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .control-panel {
            color: white;
            display: grid;
            grid-template-columns: 130px 1fr;
            gap: 5px 10px;
            font-size: 14px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
        }
        #growButton { background-color: #4CAF50; color: white; }
        #autoGrowButton { background-color: #008CBA; color: white; }
        #resetButton { background-color: #f44336; color: white; }
    </style>
</head>
<body>
    <button id="togglePanelButton" style="position:absolute;top:10px;right:20px;z-index:101;padding:8px 16px;font-size:14px;border-radius:6px;background:#222;color:#fff;border:none;cursor:pointer;">パネルを隠す</button>
    <div id="controls">
        <div class="buttons">
            <button id="growButton">10ステップ成長</button>
            <button id="autoGrowButton">シミュレーション Start</button>
            <button id="resetButton">リセット</button>
        </div>
        <div class="control-panel">
            <label for="branchProb">枝の分岐しやすさ</label>
            <input type="range" id="branchProb" min="0.1" max="1.0" step="0.05" value="0.6">
            <label for="apicalDom">上方への伸びる力</label>
            <input type="range" id="apicalDom" min="0.0" max="0.5" step="0.01" value="0.2">
            <label for="phototropism">光を求める力</label>
            <input type="range" id="phototropism" min="0.0" max="0.3" step="0.01" value="0.15">
            <label for="gravity">重力の影響</label>
            <input type="range" id="gravity" min="0.0" max="0.2" step="0.01" value="0.08">
            <label for="speedSlider">シミュレーション速度</label>
            <input type="range" id="speedSlider" min="10" max="200" step="10" value="100">
            <label for="colorVariation">色の多様性</label>
            <input type="range" id="colorVariation" min="0.0" max="0.2" step="0.01" value="0.05">
            <label for="leafTurnover">葉の更新率</label>
            <input type="range" id="leafTurnover" min="0.0" max="0.5" step="0.01" value="0.1">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, sunLight;
        let trees = [];
        let forestGroup;
        let simulationInterval = null;
        let isFirstInit = true;
        let cameraTarget = new THREE.Vector3(0, 15, 0);
        
        // ★★★ここから追加(当たり判定用)★★★
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let highlightedObject = null;
        const highlightMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        // ★★★ここまで追加★★★

        const config = {
            baseLeafColor: 0x208050,
            baseBranchColor: 0x8B4513,
            colorVariationFactor: 0.05,
            simulationIntervalMs: 100,
            maturityNodeCount: 450,
            spawnRadius: 50,
            maxTrees: 30,
            initialTreeCount: 2,
            branchingProbability: 0.6,
            apicalDominance: 0.2,
            phototropismStrength: 0.15,
            gravityStrength: 0.08,
            directionPerturbation: 0.2,
            sideBranchAngle: Math.PI / 3,
            branchAngleVariance: 0.2,
            sparseBranchingProbability: 0.3,
            candidateCount: 20,
            trunkBranchingProbability: 0.2,
            maxChildren: 3,
            initialThickness: 0.35,
            maxThickness: 2.0,
            secondaryGrowthRate: 0.005,
            lengthGrowthRate: 0.01,
            maxPointsPerTree: 50000,
            pointSize: 0.5,
            influencePointsPerBranch: 2,
            pointsPerInfluencePoint: 10,
            leafScatter: 0.8,
            leafTurnoverRate: 0.1,
            leafUpdateChunk: 100,
        };

        const GOLDEN_ANGLE = Math.PI * (3.0 - Math.sqrt(5.0));
        
        function mutateColor(baseColor, variation) {
            const newColor = new THREE.Color(baseColor);
            const hsl = {};
            newColor.getHSL(hsl);
            hsl.h += (Math.random() - 0.5) * variation;
            if (hsl.h < 0) hsl.h += 1;
            if (hsl.h > 1) hsl.h -= 1;
            hsl.s = Math.max(0.3, Math.min(1.0, hsl.s + (Math.random() - 0.5) * variation));
            hsl.l = Math.max(0.2, Math.min(0.8, hsl.l + (Math.random() - 0.5) * variation));
            newColor.setHSL(hsl.h, hsl.s, hsl.l);
            return newColor;
        }

        function gaussianRandom(mean = 0, stdev = 1) {
            const u = 1 - Math.random();
            const v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * stdev + mean;
        }

        class Node {
             constructor(parent, direction, length, thickness, depth) {
                this.parent = parent;
                this.children = [];
                this.direction = direction.normalize();
                this.length = length;
                this.thickness = thickness;
                this.isLeaf = true;
                this.depth = depth;
                this.endPoint = new THREE.Vector3();
                this.hasLeaves = true;
                this.roll = Math.random() * Math.PI * 2;
            }
        }

        class Tree {
            constructor(scene, light, basePosition, genetics) {
                this.scene = scene;
                this.sunLight = light;
                this.basePosition = basePosition;
                this.genetics = genetics;
                this.isMature = false;
                this.nodeCount = 0;

                this.branchGroup = new THREE.Group();
                forestGroup.add(this.branchGroup);
                
                this.branchMaterial = new THREE.MeshLambertMaterial({ color: this.genetics.branchColor });
                const pointsMaterial = new THREE.PointsMaterial({
                    color: this.genetics.leafColor, 
                    size: config.pointSize,
                    transparent: true, opacity: 0.6,
                    blending: THREE.NormalBlending, depthWrite: true, sizeAttenuation: true,
                });

                const pointsGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(config.maxPointsPerTree * 3);
                pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.points = new THREE.Points(pointsGeometry, pointsMaterial);
                forestGroup.add(this.points);
                
                this.pointCount = 0;
                this.allNodeEndpoints = [];
                this.leafInfluencePoints = []; 
                
                this.init();
            }

            init() {
                this.base = new Node(null, new THREE.Vector3(Math.random()-0.5, Math.random()*5, Math.random()-0.5), 2.5, config.initialThickness, 0);
                this.draw();
            }

            liveStep() {
                if (this.isMature) {
                    this._updateLeaves();
                    this.points.geometry.setDrawRange(0, this.pointCount);
                    this.points.geometry.attributes.position.needsUpdate = true;
                    return false;
                } else {
                    const result = this.grow(1);
                    return result;
                }
            }

            grow(steps = 1) {
                if (this.isMature) return false;
                let grown = false;
                for (let i = 0; i < steps; i++) {
                    if (this._growFromLightCompetition()) grown = true;
                    if (Math.random() < config.trunkBranchingProbability) if (this._tryTrunkBranching()) grown = true;
                    if (Math.random() < config.sparseBranchingProbability) if (this._promoteSparseBranching()) grown = true;
                }
                if (grown) { 
                    this._updateLeafStatus(); 
                    this._applySecondaryGrowth(); 
                    this.draw(); 
                    if (!this.isMature && this.nodeCount > config.maturityNodeCount) {
                        this.isMature = true;
                        this._redrawBranches(); 
                        return 'matured';
                    }
                }
                return grown;
            }
            
            _growFromLightCompetition() {
                const leaves = this._findLeaves();
                if (leaves.length === 0) return false;
                let bestLeaf = null;
                let maxDist = -1;
                const allObstaclePoints = trees.flatMap(tree => tree.allNodeEndpoints);
                const candidates = [];
                const candidateCount = Math.min(leaves.length, config.candidateCount);
                for(let j=0; j<candidateCount; j++) {
                    candidates.push(leaves[Math.floor(Math.random()*leaves.length)]);
                }
                for (const leaf of candidates) {
                    let minDist = Infinity;
                    for (const obstaclePos of allObstaclePoints) { 
                        if (leaf.endPoint.equals(obstaclePos)) continue; 
                        const d = leaf.endPoint.distanceTo(obstaclePos); 
                        if (d < minDist) {
                            minDist = d; 
                        }
                    }
                    if (minDist > maxDist) { 
                        maxDist = minDist; 
                        bestLeaf = leaf; 
                    }
                }
                if(bestLeaf){ 
                    if(Math.random() > 0.1) this._branchFromLeaf(bestLeaf); 
                    else bestLeaf.length += 0.05; 
                    return true; 
                }
                return false;
            }

            _branchFromLeaf(leaf) {
                if (leaf.children.length >= config.maxChildren) return;
                leaf.isLeaf = false;
                let mainDir = leaf.direction.clone();
                const perturbation = new THREE.Vector3(
                    (Math.random() - 0.5) * config.directionPerturbation,
                    (Math.random() - 0.5) * config.directionPerturbation,
                    (Math.random() - 0.5) * config.directionPerturbation
                );
                mainDir.add(perturbation);
                mainDir.lerp(new THREE.Vector3(0, 1, 0), config.apicalDominance).normalize();
                mainDir = this._applyTropism(mainDir);
                const newLength = leaf.length * 0.9;
                const newThickness = leaf.thickness * 0.85;
                leaf.children.push(new Node(leaf, mainDir, newLength, newThickness, leaf.depth + 1));
                if (leaf.children.length < config.maxChildren && leaf.depth < 10 && Math.random() < config.branchingProbability) {
                    this._addSideBranch(leaf);
                }
            }
            
            _tryTrunkBranching() {
                const candidates = [];
                const maxDepth = this._getMaxDepth() - 3;
                const find = (n) => { if(!n.isLeaf&&n.children.length<config.maxChildren&&n.depth>1&&n.depth<maxDepth) candidates.push(n); n.children.forEach(find); };
                find(this.base);
                if(candidates.length>0){ this._addSideBranch(candidates[Math.floor(Math.random()*candidates.length)]); return true; }
                return false;
            }

            _promoteSparseBranching() {
                const candidates = [];
                const find = (n) => { if(!n.isLeaf&&n.children.length<config.maxChildren) candidates.push(n); n.children.forEach(find); };
                find(this.base);
                if(candidates.length>0){ this._addSideBranch(candidates[Math.floor(Math.random()*candidates.length)]); return true; }
                return false;
            }

            _addSideBranch(node) {
                const parentDir = node.direction.clone();
                const parentQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), parentDir);
                const angle = config.sideBranchAngle + (Math.random() - 0.5) * config.branchAngleVariance;
                const sideDir = new THREE.Vector3(0, 1, 0);
                sideDir.applyAxisAngle(new THREE.Vector3(1, 0, 0), angle);
                sideDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), node.roll);
                sideDir.applyQuaternion(parentQuaternion);
                const finalDir = this._applyTropism(sideDir);
                const newLength = node.length * (0.5 + Math.random() * 0.3);
                const newThickness = node.thickness * 0.6;
                node.children.push(new Node(node, finalDir, newLength, newThickness, node.depth + 1));
                node.roll += GOLDEN_ANGLE;
            }
            
            _applyTropism(dir) {
                dir.lerp(this.sunLight.position.clone().normalize(), config.phototropismStrength).normalize();
                const gravityFactor = config.gravityStrength * (1 - Math.abs(dir.y));
                dir.lerp(new THREE.Vector3(0, -1, 0), gravityFactor).normalize();
                return dir;
            }

            _updateLeafStatus() { const d=this._getMaxDepth(); const t=(n)=>{n.hasLeaves=n.isLeaf||(d-n.depth<=4);n.children.forEach(t);};t(this.base);}

            _applySecondaryGrowth() {
                const t = (n) => {
                    const growth = config.secondaryGrowthRate / (n.depth * 0.8 + 1);
                    n.thickness = Math.min(n.thickness + growth, config.maxThickness);
                    n.length *= 1 + (config.lengthGrowthRate / (n.depth + 1));
                    n.children.forEach(t);
                };
                t(this.base);
            }

            draw() {
                this._redrawBranches();
                this._updateLeaves();
                this.points.geometry.setDrawRange(0, this.pointCount);
                this.points.geometry.attributes.position.needsUpdate = true;
            }

            _redrawBranches() {
                 while(this.branchGroup.children.length > 0) this.branchGroup.remove(this.branchGroup.children[0]);
                
                this.allNodeEndpoints = [];
                this.leafInfluencePoints = [];
                this.nodeCount = 0;

                this._recursiveDrawAndCollect(this.base, this.basePosition);
            }
            
            _recursiveDrawAndCollect(node, parentEndPos) {
                this.nodeCount++;
                const startPos = parentEndPos;
                const endPos = new THREE.Vector3().addVectors(startPos, node.direction.clone().setLength(node.length));
                node.endPoint.copy(endPos);
                this.allNodeEndpoints.push(endPos);
                const branchMesh = this._createCylinder(startPos, endPos, node.thickness, this.branchMaterial);

                // ★★★ここから変更★★★
                branchMesh.userData = { tree: this, node: node, originalMaterial: this.branchMaterial };
                // ★★★ここまで変更★★★

                this.branchGroup.add(branchMesh);
                if (node.hasLeaves) {
                    for (let i = 0; i < config.influencePointsPerBranch; i++) {
                        const influencePoint = new THREE.Vector3().lerpVectors(startPos, endPos, Math.random());
                        this.leafInfluencePoints.push(influencePoint);
                    }
                }
                node.children.forEach(child => this._recursiveDrawAndCollect(child, endPos));
            }

            _updateLeaves() {
                if (this.leafInfluencePoints.length === 0) {
                    this.pointCount = 0;
                    return;
                }
                const positions = this.points.geometry.attributes.position.array;
                const targetPointCount = Math.min(config.maxPointsPerTree, this.leafInfluencePoints.length * config.pointsPerInfluencePoint);
                const turnoverCount = Math.floor(this.pointCount * config.leafTurnoverRate);
                for (let i = 0; i < turnoverCount; i++) {
                    const indexToUpdate = Math.floor(Math.random() * this.pointCount);
                    this._generateSingleLeaf(indexToUpdate, positions);
                }
                if (this.pointCount < targetPointCount) {
                    const newPointsCount = Math.min(targetPointCount - this.pointCount, config.leafUpdateChunk);
                    const startIndex = this.pointCount;
                    for (let i = 0; i < newPointsCount; i++) {
                        this._generateSingleLeaf(startIndex + i, positions);
                    }
                    this.pointCount += newPointsCount;
                } else if (this.pointCount > targetPointCount) {
                     this.pointCount = Math.max(targetPointCount, this.pointCount - config.leafUpdateChunk);
                }
            }

            _generateSingleLeaf(index, positions) {
                if (this.leafInfluencePoints.length === 0) return;
                const anchorPoint = this.leafInfluencePoints[Math.floor(Math.random() * this.leafInfluencePoints.length)];
                const scatter = config.leafScatter;
                const x = anchorPoint.x + gaussianRandom(0, scatter);
                const y = anchorPoint.y + gaussianRandom(0, scatter);
                const z = anchorPoint.z + gaussianRandom(0, scatter);
                const bufferIndex = index * 3;
                positions[bufferIndex] = x;
                positions[bufferIndex + 1] = y;
                positions[bufferIndex + 2] = z;
            }

            dispose() {
                forestGroup.remove(this.branchGroup);
                forestGroup.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
                this.branchMaterial.dispose();
            }

            _findLeaves() { const l=[]; const t=(n)=>{if(n.isLeaf)l.push(n);n.children.forEach(t);};t(this.base); return l;}
            _getMaxDepth() { let d=0; const t=(n,c)=>{if(c>d)d=c;n.children.forEach(ch=>t(ch,c+1));};t(this.base,0); return d;}
            _createCylinder(start, end, radius, material) {
                if(start.equals(end)) return new THREE.Mesh();
                const dir=new THREE.Vector3().subVectors(end,start); const h=dir.length();
                const geo=new THREE.CylinderGeometry(Math.max(0.02,radius),Math.max(0.02,radius),h,8);
                const up=new THREE.Vector3(0,1,0);
                geo.applyQuaternion(new THREE.Quaternion().setFromUnitVectors(up, dir.clone().normalize()));
                geo.translate(start.x+dir.x/2, start.y+dir.y/2, start.z+dir.z/2);
                const mesh=new THREE.Mesh(geo,material); mesh.castShadow=true; return mesh;
            }
        }
        
        function updateCameraTarget() {
            if (trees.length === 0) {
                cameraTarget.set(0, 15, 0);
                return;
            }
            const centerOfForest = new THREE.Vector3();
            trees.forEach(tree => {
                centerOfForest.add(tree.basePosition);
            });
            centerOfForest.divideScalar(trees.length);
            cameraTarget.set(centerOfForest.x, 15, centerOfForest.z);
        }

        function spawnNewTree(position, parentTree = null) {
            if (trees.length >= config.maxTrees) return;
            
            let genetics;
            if (parentTree) {
                genetics = {
                    leafColor: mutateColor(parentTree.genetics.leafColor, config.colorVariationFactor),
                    branchColor: mutateColor(parentTree.genetics.branchColor, config.colorVariationFactor / 2)
                };
            } else {
                genetics = {
                    leafColor: new THREE.Color(config.baseLeafColor),
                    branchColor: new THREE.Color(config.baseBranchColor)
                };
            }
            
            const newTree = new Tree(scene, sunLight, position, genetics);
            trees.push(newTree);
            updateCameraTarget();
        }

        function createShrubbery(shrubCount, grassPerShrub, scatterArea, shrubRadius) {
            const totalGrassCount = shrubCount * grassPerShrub;
            const grassGeometry = new THREE.ConeGeometry(0.15, 2.0, 4, 1);
            grassGeometry.translate(0, 1.0, 0); 
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x1a9d29 });
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, totalGrassCount);
            grassMesh.castShadow = true;
            grassMesh.receiveShadow = true;

            const dummy = new THREE.Object3D();
            const groundY = -10 + 0.01;
            let grassIndex = 0;

            for (let i = 0; i < shrubCount; i++) {
                const shrubX = (Math.random() - 0.5) * scatterArea;
                const shrubZ = (Math.random() - 0.5) * scatterArea;

                for (let j = 0; j < grassPerShrub; j++) {
                    if (grassIndex >= totalGrassCount) break;

                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.abs(gaussianRandom(0, shrubRadius * 0.5));
                    
                    const grassX = shrubX + Math.cos(angle) * radius;
                    const grassZ = shrubZ + Math.sin(angle) * radius;
                    
                    dummy.position.set(grassX, groundY, grassZ);
                    dummy.rotation.y = Math.random() * Math.PI * 2;
                    const scale = 0.6 + Math.random() * 0.7;
                    dummy.scale.set(scale, scale, scale);
                    dummy.rotation.z = (Math.random() - 0.5) * 0.3;
                    dummy.rotation.x = (Math.random() - 0.5) * 0.3;

                    dummy.updateMatrix();
                    grassMesh.setMatrixAt(grassIndex, dummy.matrix);
                    grassIndex++;
                }
            }
            grassMesh.instanceMatrix.needsUpdate = true;
            forestGroup.add(grassMesh);
        }

        function init() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                const button = document.getElementById('autoGrowButton');
                button.textContent = 'シミュレーション Start';
                button.style.backgroundColor = '#008CBA';
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x11111a);
            scene.fog = new THREE.Fog(0x11111a, 50, 200);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 60);
            
            if (isFirstInit) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);
            }
            
            trees.forEach(tree => tree.dispose());
            if(forestGroup) scene.remove(forestGroup);
            trees = [];

            forestGroup = new THREE.Group();
            scene.add(forestGroup);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
            sunLight.position.set(20, 40, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200; 
            scene.add(sunLight);

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshLambertMaterial({ color: 0x3a3a4a }));
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -10;
            ground.receiveShadow = true;
            scene.add(ground);

            createShrubbery(150, 40, 180, 4);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            const initialTreeCount = Math.min(config.initialTreeCount, config.maxTrees);
            for (let i = 0; i < initialTreeCount; i++) {
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnDist = config.spawnRadius * Math.random();
                const position = new THREE.Vector3(
                    Math.cos(spawnAngle) * spawnDist,
                    -10, // 地面の高さ
                    Math.sin(spawnAngle) * spawnDist
                );
                spawnNewTree(position, null);
            }
            
            updateCameraTarget();
            controls.target.copy(cameraTarget);
            
            if (isFirstInit) {
                setupEventListeners();
                animate();
                isFirstInit = false;
            }
        }
        
        function setupEventListeners() {
            document.getElementById('growButton').addEventListener('click', () => {
                trees.forEach(tree => tree.grow(10));
            });
            document.getElementById('resetButton').addEventListener('click', init);
            document.getElementById('autoGrowButton').addEventListener('click', toggleSimulation);
            document.getElementById('branchProb').addEventListener('input', (e) => config.branchingProbability = parseFloat(e.target.value));
            document.getElementById('apicalDom').addEventListener('input', (e) => config.apicalDominance = parseFloat(e.target.value));
            document.getElementById('phototropism').addEventListener('input', (e) => config.phototropismStrength = parseFloat(e.target.value));
            document.getElementById('gravity').addEventListener('input', (e) => config.gravityStrength = parseFloat(e.target.value));
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                config.simulationIntervalMs = 210 - parseInt(e.target.value, 10);
                if (simulationInterval) {
                    toggleSimulation();
                    toggleSimulation();
                }
            });
            document.getElementById('colorVariation').addEventListener('input', (e) => {
                config.colorVariationFactor = parseFloat(e.target.value);
            });
            document.getElementById('leafTurnover').addEventListener('input', (e) => {
                config.leafTurnoverRate = parseFloat(e.target.value);
            });
            document.getElementById('togglePanelButton').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const btn = document.getElementById('togglePanelButton');
                if (controls.style.display === 'none') {
                    controls.style.display = 'flex';
                    btn.textContent = 'パネルを隠す';
                } else {
                    controls.style.display = 'none';
                    btn.textContent = 'パネルを表示';
                }
            });
            window.addEventListener('resize', onWindowResize, false);

            // ★★★ここから追加★★★
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onMouseClick, false);
            // ★★★ここまで追加★★★
        }

        // ★★★ここから追加 (新しい関数) ★★★
        function onMouseMove(event) {
            // 他のUI操作中は無効にする
            if(event.target.tagName === 'INPUT') return;
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
             // 他のUI操作中は無効にする
            if(event.target.tagName !== 'CANVAS') return;
            event.preventDefault();
            if (highlightedObject && highlightedObject.userData.node) {
                const { tree, node } = highlightedObject.userData;
                pruneBranch(tree, node);
            }
        }

        function pruneBranch(tree, nodeToPrune) {
            // 根のノードは剪定しない
            if (!nodeToPrune.parent) {
                console.log("Cannot prune the base of the tree.");
                return;
            }

            const parentNode = nodeToPrune.parent;
            const index = parentNode.children.indexOf(nodeToPrune);
            if (index > -1) {
                // ハイライトを元に戻す
                if (highlightedObject) {
                    highlightedObject.material = highlightedObject.userData.originalMaterial;
                    highlightedObject = null;
                }
                
                parentNode.children.splice(index, 1);
                
                // 剪定後に葉を持たなくなった枝が再び葉を持つようにフラグを更新
                if (parentNode.children.length === 0) {
                    parentNode.isLeaf = true;
                }
                
                // 木全体を再描画して変更を反映
                tree.draw();
            }
        }
        
        function checkIntersection() {
            raycaster.setFromCamera(mouse, camera);

            // forestGroup内の全ての子オブジェクト(木の枝グループや茂み)を再帰的に探索
            const intersects = raycaster.intersectObjects(forestGroup.children, true);

            // 前のフレームでハイライトしていたオブジェクトを元に戻す
            if (highlightedObject) {
                highlightedObject.material = highlightedObject.userData.originalMaterial;
                highlightedObject = null;
            }
            
            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;
                // userData.nodeが存在するオブジェクト(＝枝)のみを対象とする
                if (firstIntersected.userData && firstIntersected.userData.node) { 
                    highlightedObject = firstIntersected;
                    highlightedObject.material = highlightMaterial;
                }
            }
        }
        // ★★★ここまで追加★★★

        function toggleSimulation() {
            const button = document.getElementById('autoGrowButton');
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                button.textContent = 'シミュレーション Start';
                button.style.backgroundColor = '#008CBA';
            } else {
                simulationInterval = setInterval(() => {
                    let hasMatureTree = false;
                    trees.forEach(tree => {
                        const result = tree.liveStep();
                        if (result === 'matured' && !hasMatureTree) {
                             hasMatureTree = true;
                            const parentPos = tree.basePosition;
                            const spawnAngle = Math.random() * Math.PI * 2;
                            const spawnDist = config.spawnRadius * (0.7 + Math.random() * 0.6);
                            const offset = new THREE.Vector3(Math.cos(spawnAngle) * spawnDist, 0, Math.sin(spawnAngle) * spawnDist);
                            const newPos = new THREE.Vector3().addVectors(parentPos, offset);
                            spawnNewTree(newPos, tree); 
                        }
                    });
                }, config.simulationIntervalMs);
                button.textContent = 'シミュレーション Stop';
                button.style.backgroundColor = '#ff9800';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ★★★ここから追加★★★
            checkIntersection();
            // ★★★ここまで追加★★★

            controls.target.lerp(cameraTarget, 0.05);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>