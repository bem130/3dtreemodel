<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>自然な木の3D画像生成プログラム</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="info">マウスドラッグで回転 / ホイールでズーム</div>
    <div id="controls">
        <button id="growButton">10ステップ成長</button>
        <button id="resetButton">リセット</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let tree;

        // --- 木のデータ構造とロジック ---

        class Node {
            constructor(parent, direction, length, thickness) {
                this.parent = parent;
                this.children = [];
                this.direction = direction;
                this.length = length;
                this.thickness = thickness;
                this.isLeaf = true;
            }
        }

        class Tree {
            constructor(scene) {
                this.scene = scene;
                this.objectGroup = new THREE.Group();
                this.scene.add(this.objectGroup);
                this.init();
            }

            init() {
                while(this.objectGroup.children.length > 0){
                    this.objectGroup.remove(this.objectGroup.children[0]);
                }
                this.base = new Node(null, new THREE.Vector3(0, 1, 0), 1.5, 0.2);
                this.draw();
            }

            grow(steps = 1) {
                for (let i = 0; i < steps; i++) {
                    if (this._findLeaves().length === 0) continue; // 成長できる葉がない場合はスキップ

                    if (Math.random() > 0.2) { // 分岐の発生確率を少し上げる
                        this._addNewBranch();
                    } else {
                        this._thickenTrunk();
                    }
                }
                this.draw();
            }
            
            /**
             * ★修正箇所: 新たな葉(枝)の発生ロジックを「分岐」するように変更
             */
            _addNewBranch() {
                const leaves = this._findLeaves();
                if (leaves.length === 0) return;

                const targetLeaf = leaves[Math.floor(Math.random() * leaves.length)];
                targetLeaf.isLeaf = false; // 選ばれた葉は「節点」になる

                // 分岐する枝の数を決定 (今回は2つに分岐)
                const branchCount = 2; 
                for (let i = 0; i < branchCount; i++) {
                    // 分岐するそれぞれの枝の形質を決定
                    const newDir = this._getSlightlyRandomDirection(targetLeaf.direction);
                    const newLength = targetLeaf.length * (0.7 + Math.random() * 0.2);
                    // 分岐した枝は親よりも細くなる
                    const newThickness = targetLeaf.thickness * 0.6; 

                    const newNode = new Node(targetLeaf, newDir, newLength, newThickness);
                    targetLeaf.children.push(newNode); // 節点に新しい子（葉）を追加
                }
            }

            _thickenTrunk() {
                const traverse = (node) => {
                    if (!node.parent) { // 基点のみ太く、長くする
                         node.thickness *= 1.015;
                         node.length *= 1.005;
                    }
                    node.children.forEach(traverse);
                };
                traverse(this.base);
            }

            draw() {
                while(this.objectGroup.children.length > 0){
                    this.objectGroup.remove(this.objectGroup.children[0]);
                }
                this._recursiveDraw(this.base, new THREE.Vector3(0, -8, 0)); // 少しY座標を下げる
            }

            _recursiveDraw(node, parentEndPos) {
                const startPos = parentEndPos;
                const endPos = new THREE.Vector3().addVectors(startPos, node.direction.clone().setLength(node.length));

                const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const branchMesh = this._createCylinder(startPos, endPos, node.thickness, branchMaterial);
                this.objectGroup.add(branchMesh);
                
                if (node.isLeaf) {
                    const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, side: THREE.DoubleSide });
                    const leafShape = new THREE.Shape();
                    const leafLength = 1.0;
                    const leafWidth = 0.6;
                    leafShape.ellipse(0, leafLength / 2, leafWidth, leafLength, 0, 2 * Math.PI, false, 0);

                    const leafGeometry = new THREE.ShapeGeometry(leafShape);
                    const leafMesh = new THREE.Mesh(leafGeometry, leafMaterial);
                    
                    leafMesh.position.copy(endPos);
                    
                    const up = new THREE.Vector3(0, 1, 0);
                    // 枝の方向ベクトルが真上(0,1,0)や真下(0,-1,0)の場合、外積が0ベクトルになりエラーになるのを防ぐ
                    if (up.distanceTo(node.direction.clone().normalize()) < 0.001 || up.distanceTo(node.direction.clone().normalize().negate()) < 0.001) {
                         leafMesh.lookAt(new THREE.Vector3(endPos.x+1, endPos.y+1, endPos.z+1));
                    } else {
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, node.direction.clone().normalize());
                        leafMesh.quaternion.copy(quaternion);
                    }
                    this.objectGroup.add(leafMesh);
                }

                node.children.forEach(child => {
                    this._recursiveDraw(child, endPos);
                });
            }

            _findLeaves() {
                const leaves = [];
                const traverse = (node) => {
                    if (node.isLeaf) {
                        leaves.push(node);
                    }
                    node.children.forEach(traverse);
                };
                traverse(this.base);
                return leaves;
            }

            _getSlightlyRandomDirection(baseDirection) {
                return new THREE.Vector3(
                    baseDirection.x + (Math.random() - 0.5) * 1.8,
                    baseDirection.y + (Math.random() - 0.5) * 1.0,
                    baseDirection.z + (Math.random() - 0.5) * 1.8
                ).normalize();
            }

            _createCylinder(start, end, radius, material) {
                const direction = new THREE.Vector3().subVectors(end, start);
                const orientation = new THREE.Matrix4();
                const up = new THREE.Vector3(0, 1, 0);
                
                 // ゼロベクトル外積の対策
                if (start.equals(end) || direction.length() === 0) return new THREE.Mesh();
                if (up.distanceTo(direction.clone().normalize()) < 0.001) {
                    // ほぼ真上を向いている
                    orientation.identity();
                } else if (up.distanceTo(direction.clone().normalize().negate()) < 0.001) {
                    // ほぼ真下を向いている
                    orientation.makeRotationX(Math.PI);
                } else {
                     const axis = new THREE.Vector3().crossVectors(up, direction).normalize();
                     const angle = Math.acos(up.dot(direction.clone().normalize()));
                     orientation.makeRotationAxis(axis, angle);
                }

                const height = direction.length();
                const geometry = new THREE.CylinderGeometry(radius, radius, height, 10);
                geometry.applyMatrix4(orientation);
                
                geometry.translate(
                    start.x + direction.x / 2,
                    start.y + direction.y / 2,
                    start.z + direction.z / 2
                );
                return new THREE.Mesh(geometry, material);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333355);
            scene.fog = new THREE.Fog(0x333355, 20, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;
            camera.position.y = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            tree = new Tree(scene);

            document.getElementById('growButton').addEventListener('click', () => tree.grow(10));
            document.getElementById('resetButton').addEventListener('click', () => tree.init());
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>